********************************************************
- .find
********************************************************
배열.find(찾는항목 = 찾는항목과 조건)
const array = [1,3,13,5,20,40]
const found = array.find(a=> a>10)
// 콘솔 10

>> 첫번째 요소의 값을 반환 / 없으면 undefined



- .find(), findIndex() 차이
find는 찾은 항목을 출력. findIndex는 찾아진 아이템의 인덱스 번호(순서)를 반환


********************************************************
- .length
********************************************************
배열.length
>> 배열의 아이템 갯수 반환


********************************************************
- .concat()
********************************************************
원본배열.concat(새배열)
>> 두개의 배열 데이터를 병합하여 새 배열 데이터 출력
>> 원본배열이 수정되지 않고 새배열을 추가


********************************************************
- .forEach()
********************************************************
배열.forEach(function(element, index, array){
})
const aa = [a,b,c]
aa.forEach(function(ele,idx,arr){
  console.log(ele,idx,arr)
})
// a 0 aa배열 / b 1 aa배열 / c 2 aa배열
>> 배열의 갯수만큼 콜백함수 반복 실행, array는 잘 안쓰임


********************************************************
-.map()
********************************************************
cosnt 새배열 = 배열.map(function(element, index){
  return 반환값
})
>> 배열의 값이 return되어 새배열로 반환된다

--- forEach 비교--------------------------------
const aa = [a,b,c]

const a = aa.forEach(function(ele,idx){
  console.log(`${ele}-${idx}`)
})
console.log(a)
// undefined 출력

const b = aa.map(function(ele,idx){
  return `${ele}-${idx}`
})
console.log(b)
// ["a-0","b-1","c-2"] 출력

const b = aa.map(function(ele,idx){
  return {
    num:idx,
    name:ele
  }
})
console.log(b)
// [{num:0, name:a},{num:1, name:b},{num:2, name:c}] 출력
// 객체 데이터 배열로 생성 가능

**map은 return이 있어서 콜백함수 밖으로 반환 한다
b라는 변수에 할당이 가능하여 새로운 배열 출력




화살표 함수 변경 --------

const a = aa.forEach((ele,idx)=>{})

const b = aa.map((ele,idx)=>({
    num:idx,
    name:ele
}))
>> 객체 데이터를 출력 시 ()로 감싸주어야 함
()=>({})




********************************************************
- .filter()
********************************************************
cosnt 새배열 = 배열.filter(function(){})
>> 배열이 true인 경우에 새로운 배열로 넣어준다

const aa = [1,2,3,4]

--- map 비교--------------------------------
const a = aa.map(qq => {
  return qq < 3
})
console.log(a)
//[true,true,false,false]

const b = aa.filter(qq=>{
  return qq < 3
})
console.log(b)
// [1,2]

const b = aa.filter(qq=> q < 3) >> 로 줄임 가능

** map은 새로운 배열 반환 시 아이템의 개수만큼 똑같이 만들어짐
filter는 true것만 필터링해서 반환되니까 원본 아이템 수와 다름




********************************************************
- .includes()
********************************************************
const a = 배열.includes(항목)
>> 배열안에 항목이 포함되어 있는지 확인하여 true/false 출력

const aa = [1,2,3,4]
const a = aa.includes(3)
// true




********************************************************
- .push()
********************************************************
const a = 배열
a.push(새 아이템)
>> 원본수정됨 / 새로운 아이템 맨뒤에 추가




********************************************************
- .unshift()
********************************************************
const a = 배열
a.unshift(새 아이템)
>> 원본수정됨 / 새로운 아이템 맨앞에 추가



********************************************************
- .reverse()
********************************************************
const a = 배열
a.reverse()
>> 원본수정됨 / 배열의 순서 뒤집어짐



********************************************************
- .splice()
********************************************************
const a = 배열
a.splice(시작 index값, 지우는 개수)
>> 원본수정됨 / 배열에서 시작 index값 부터 지우는 개수만큼 삭제

**
ex)  a.splice(시작 index값, 0, 새값)
지우는 개수에 0을 쓰고 새로운 값을 넣으면 중간에 아이템 추가
const a = [1,2,3,4]
a.splice(2, 0, 10)
// [1,2,10,3,4]

const a = [1,2,3,4]
a.splice(2, 1, 10)
// [1,2,10,4]


